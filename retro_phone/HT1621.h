#ifndef HT1621_h
#define HT1621_h

#if defined(ARDUINO) && (ARDUINO >= 100)
#include <Arduino.h>
#else
#include <WProgram.h>
#endif

//	доступные буквы   строки			AbCdEFGHIJLnOPqrStUY		(буквы указаны в том регистре (строчные/ПРОПИСНЫЕ) в каком они выводятся на дисплей, в функции print регистр букв значения не имеет)
//	доступные символы строки			()[]{}:;=.,'"?-_*			(символ * выводится как символ ° - градус)
//	"кривые"  буквы   строки			KMvWXZ						(буквы выводятся, но их интерпретация может вызвать затруднение)
//	
//	ПАРАМЕТРЫ ФУНКЦИЙ:
//	строка							-	строка букв и символов  	все допустимые буквы и символы описаны выше, иные выводятся как пробел
//	число							-	от 0 до 4294967295			целочисленное положительное число, при указании отрицательного числа, оно будет преобразовано в формат дополнения до двух
//	начальная позиция				-	число от 0 до 15			по умолчанию = 0
//	система счисления				-	BIN, OCT, DEC, HEX			по умолчанию = DEC (допускается указание чисел для не стандартных систем счисления)
//	длинна числа					-	число от 1 до 15			по умолчанию = количеству разрядов в выводимом числе
//																	если указать значение больше чем количество разрядов, то перед числом будут выведены нули
//																	если указать значение меньше чем количество разрядов, то будут отброшены старшие разряды числа
//	true/false						-	1/0 или true/false			по умолчанию = true
//	№ символа						-	число от 0 до 15	
//	
//	ДОСТУПНЫЕ ФУНКЦИИ:
//	LCD.begin(WD,DATA,CS)			-	инициализация модуля		достаточно однократного обращения к функции, но обязательно до указанных ниже
//	clrScr, print, symbol			-								указанные функции работают с буфером LCD (с массивом), а не выводят данные
//	LCD.clrScr()					-	очистка буфера LCD
//	LCD.print("строка");			-	создание строки				может принимать от 1 до 2 параметров - строка, начальная позиция
//	LCD.print(число);				-	создание числа				может принимать от 1 до 4 параметров - число,  начальная позиция, система счисления, длинна числа
//	LCD.symbol(номер,true/false);	-	показать/скрыть символ		может принимать от 1 до 2 параметров - № символа, true/false
//	LCD.update();					-	вывод буфера LCD			всё что мы натворили с буфером LCD, отобразится на дисплее.

class HT1621{
	public:
	/**	пользовательские функции **/
		void	begin(uint8_t,uint8_t,uint8_t);					//	инициализ-я	модуля					(номер CLK, номер DAT, номер CS)
		void	clrScr();										//	очистка		массива вывода на дисплей buffer
		void	print(char*,uint8_t=0);							//	запись		строки в массив buffer	(строка , позиция первого символа на дисплее)
		void	print(uint32_t,uint8_t=0,uint8_t=DEC,uint8_t=17);//	запись		числа  в массив buffer	(число , позиция первого символа на дисплее , система счисления , длинна числа)
		void	symbol(uint8_t,bool=true);						//	символ		вкл/выкл				(номер символа от 0 до 9 , true/false)
		void	update();										//	обновление	экрана

	/**	пользовательские переменные **/
		uint8_t	buffer[16];										//	буфер		массив из 16 байт для вывода на дисплей
	   uint16_t	bufferSimv				= 0;					//	буфер		число  из 16 бит, каждый бит которого вкл/выкл дополнительный символ
	
	private:
	/**	внутренние переменные **/
	//			выводы используемые шинами						//	I2C и SPI	используют аппаратные выводы.
		uint8_t	SI3_line_CLK			= SCK;					//	вывод CLK	шины SI3 (CLocK)
		uint8_t	SI3_line_DAT			= MOSI;					//	вывод DAT	шины SI3 (DATa)
		uint8_t	SI3_line_RES			= SS;					//	вывод RES	шины SI3 (Chip Select) Контроль за выводом не выполняется функциями работы с шиной
	//			массив режима работы шины
	   uint16_t	SI3_mass_STATUS[0x06]	= {50,1000,1,0,1,0};	//  скорость	работы шины в кГц (макс F_CPU/354), ожидание импульса на CLK в циклах, флаг успешного результата, режим работы SI3 (0-3), флаг работы в режиме мастера, флаг переворачивания данных младшим битом вперед
	//			массивы отображения символов
		uint8_t	LSD_simv_BIT[16]		= {						//	массив		дополнительных символов (№ элемента массива = № символа, значение элемента массива = № разряда на LCD = № элемента массива buffer, старший бит которого «h» отвечает за отображение этого символа)
				/*	 0	=	_|¯	*/			0,
				/*	 1	=	¤	*/			2,
				/*	 2	=	▫◄↔	*/			3,
				/*	 3	=	♫	*/			5,
				/*	 4	=	○	*/			6,
				/*	 5	=	□#□	*/			7,
				/*	 6	=	→◊	*/			10,
				/*	 7	=	○●	*/			11,
				/*	 8	=	⌐○	*/			13,
				/*	 9	=	▫[/]*/			15,
										  };
		uint8_t	LSD_segm_BIT[46]		= {/* hgfedcba */		//	массив		установки сегментов
				/*	 0	=	0	*/			0b01111101,			//		    e
				/*	 1	=	1	*/			0b00000101,			//		  ─────
				/*	 2	=	2	*/			0b01011011,			//		 │     │
				/*	 3	=	3	*/			0b00011111,			//		f│     │a
				/*	 4	=	4	*/			0b00100111,			//		 │  b  │
				/*	 5	=	5	*/			0b00111110,			//		  ─────
				/*	 6	=	6	*/			0b01111110,			//		 │     │
				/*	 7	=	7	*/			0b00010101,			//		g│     │c
				/*	 8	=	8	*/			0b01111111,			//		 │     │
				/*	 9	=	9	*/			0b00111111,			//		  ─────
				/*	10	=	A	*/			0b01110111,			//		    d
				/*	11	=	B	*/			0b01101110,
				/*	12	=	C	*/			0b01111000,
				/*	13	=	D	*/			0b01001111,
				/*	14	=	E	*/			0b01111010,
				/*	15	=	F	*/			0b01110010,
				/*	16	=	G	*/			0b01111100,
				/*	17	=	H	*/			0b01100111,
				/*	18	=	I	*/			0b00000101,
				/*	19	=	J	*/			0b01001101,
				/*	20	=	K	*/			0b01100011,
				/*	21	=	L	*/			0b01101000,
				/*	22	=	M	*/			0b01010100,
				/*	23	=	N	*/			0b01000110,
				/*	24	=	O	*/			0b01111101,
				/*	25	=	P	*/			0b01110011,
				/*	26	=	Q	*/			0b00110111,
				/*	27	=	R	*/			0b01000010,
				/*	28	=	S	*/			0b00111110,
				/*	29	=	T	*/			0b01101010,
				/*	30	=	U	*/			0b01101101,
				/*	31	=	V	*/			0b01001100,
				/*	32	=	W	*/			0b01011100,
				/*	33	=	X	*/			0b01100101,
				/*	34	=	Y	*/			0b00101111,
				/*	35	=	Z	*/			0b01011001,
				/*	36	=	({[	*/			0b01111000,
				/*	37	=	)}]	*/			0b00011101,
				/*	38	=	:;=	*/			0b00001010,
				/*	39	=	.,	*/			0b01000000,
				/*	40	=	'	*/			0b00000001,
				/*	41	=	"	*/			0b00100001,
				/*	42	=	?	*/			0b01010011,
				/*	43	=	*	*/			0b00110011,
				/*	44	=	-	*/			0b00000010,
				/*	45	=	_	*/			0b00001000,
										  };

	/**	внутренние функции **/
	//			инициализация шины
		void	SI3_func_begin			(uint8_t, uint8_t);		//	установка	скорости работы шины SI3 и режима её работы	(номер CLK, номер DAT)
	//			работа с битами
		void	SI3_func_WRITE_BITS		(uint32_t, uint8_t);	//	передача	нескольких бит из 32-битного числа			(число, количество младших бит числа для передачи)
};

#endif